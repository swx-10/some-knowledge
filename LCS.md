## 最长公共字串(LongestCommon Substring)
最长公共子串，即给定两个字符串，求出它们之间最长的相同子字符串，并且要求改字符串必须连续。
#### 1、问题定义
给定两个字符串：str1=acbcbcef、str2=abcbced，求出str和str2的最长公共子串为bcbce，公共子串长度为5。
#### 2、代码实现
最直接的解法是找出两个字符串的所有的字串进行比较看它们是否相同，然后取得相同最长的那个。对于一个长度为n的字符串，他有n(n+1)/2个非空子串。假设两个字符串的长度都为n，那么通过比较各个子串的复杂度大致为$O(n^4)$。
因此，为了加快速度，可以使用动态规划的方式，用一个矩阵记录两个字符串中全部位置的两个字符之间的匹配状况，如果匹配成功则为1，否则为0。而后求出对角线最长的1的序列，其对应位置就是最长公共字串的位置。
```python
def LongestCommonSubstring(s1, s2):
    record = [0 for _ in range(len(s2)+1)]
    #res为公共子串的长度
    #index为公共子串结尾的位置索引
    res,index = 0,0
    for i in range(len(s1)):
        for j in range(len(s2)-1,-1,-1):
            if s1[i] == s2[j]:
                if j == 0:
                    record[j] = 1
                else:
                    record[j] = record[j-1] + 1
            else:
                record[j] = 0
            if res < record[j]:
                res = record[j]
                index = j
    return s2[index-res+1:index+1]
```
#### 3、应用场景
实际上，在搜索场景中，该方案也有应用场景，例如，一个用户在网站搜索框中输入一个字符串hish，但其实用户想输入的是fish，但是这个网站的字典里只有fish和vista这两个相似单词。算法需要猜测用户到底想搜索的是什么字符串？  
因此，在实现上就可以采用动态规划的方法进行处理，目标是将某个指标最大化，在这个例子中，要找出两个单词的公共字串，更大的那个即为结果。

## 最长公共子序列(LongestCommon Subsequence)
最长公共子序列，是子序列问题中的重要一类，区别于最长公共子串，最长公共字串要求连续，而最长公共子序列不要求连续。  
例如，对于cnblogs、belong两个字符串，最长公共子序列为blog（cn blogs, be lon g），最长公共子串为lo（cnb logs, be long）。
#### 1、问题定义
在定义上，一个序列S任意删除若干个字符得到新序列T，则T叫做S的子序列；
在给定两个序列X和Y的公共子序列中，长度最长的那个，定义为X和Y的最长公共子序列。  
>例如:  
字符串13455与245576的最长公共子序列为455；
字符串acdfg与adfc的最长公共子序列为adf；
#### 2、代码实现
针对这类问题，最直接的做法就是用动态回归的思想，一个矩阵记录两个字符串的匹配情况，如果匹配则左上方的值加1，不然为左方和上方的最大值。一个矩阵记录转移方向，而后根据转移方向，回溯找到最长子序列。
```python
def LongestCommonSubsequence(s1, s2):
    #生成字符串长度加1的0矩阵，m用来保存对应位置匹配的结果
    m = [[0 for _ in range(len(s2)+1)] for _ in range(len(s1)+1)]
    #d用来记录转移方向
    d = [[None for _ in range(len(s2)+1)] for _ in range(len(s1)+1)]

    for p1 in range(len(s1)):
        for p2 in range(len(s2)):
            if s1[p1] == s2[p2]: #字符匹配成功，则在该位置的值为左上方的值加1
                m[p1+1][p2+1] = m[p1][p2]+1
                d[p1+1][p2+1] = 'ok'
            elif m[p1+1][p2] > m[p1][p2+1]: #左值大于上值，该位置的值为左值，并标记回溯时的方向
                m[p1+1][p2+1] = m[p1+1][p2]
                d[p1+1][p2+1] = 'left'
            else: #上值大于左值，该位置的值为上值，并标记方向
                m[p1+1][p2+1] = m[p1][p2+1]
                d[p1+1][p2+1] = 'up'
    (p1,p2) = (len(s1),len(s2))
    s = []
    while m[p1][p2]: #不为None时
        c = d[p1][p2]
        if c == 'ok': #匹配成功，插入该字符，并向左上角寻找下一个
            s.append(s1[p1-1])
            p1 -= 1
            p2 -= 1
        if c == 'left': #根据标记，向左寻找下一个
            p2 -= 1
        if c == 'up': #根据标记，向上寻找下一个
            p1 -= 1
    s.reverse()
    return ''.join(s)
```
#### 3、应用场景
在具体应用上，可用于模糊搜索、字符串相似度计算等诸多场景。例如：  
在图形相似处理、媒体流的相似比较、计算生物学方面，生物学家常常利用该算法进行基因序列比对，由此推测序列的结构、功能和演化过程。  
在自然语言处理领域，最长公共子序列可以描述两段文字之间的“相似度”，即它们的雷同程度，从而能够用来辨别抄袭。另一方面，对一段文字进行修改之后，计算改动前后文字的最长公共子序列，将除此子序列外的部分提取出来，这种方法判断修改的部分，往往十分准确。

### 参考文献
https://mp.weixin.qq.com/s/aJ-GuV3k7WRaSs7YR1Gl_w